  <!DOCTYPE html>
  <html>
    <head>
      <link id="favicon" rel="shortcut icon" type="image/png" href="public/favicon.png" />
      <meta content="text/html;charset=utf-8" http-equiv="Content-Type">
      <meta content="utf-8" http-equiv="encoding">
      <link href="https://fonts.googleapis.com/css2?family=Zen+Kaku+Gothic+Antique:wght@300&amp;display=swap" rel="stylesheet">
    </head>
    <body style="margin: 0">
      <div id="main"></div>
    </body>
    <script>class MatchError extends Error {}

const allEntries = (obj) =>
  Reflect.ownKeys(obj).map((k) => [Sym.new(k), obj[k]]);

class Schema {
  nil_q() {
    return new Bool(false);
  }
  static for(schema) {
    if (schema instanceof Schema) return schema;
    if (schema instanceof List) return new ListSchema(schema);
    if (schema instanceof Array) return new ListSchema(schema);
    if (schema instanceof Function) return new FnSchema(schema);
    if (schema instanceof Record) return new RecordSchema(schema);
    if (schema === undefined) return new AnySchema();
    // TODO: this should be more specific, why?
    const literals = [Bool, Int, Float, Str, Sym, Nil];
    if (literals.includes(schema.constructor)) return new LiteralSchema(schema);
    if (typeof schema === "object") return new RecordSchema(schema);
  }

  static case(value, cases) {
    const fn = cases.first((list) => {
      const schema = list.__lookup__(new Int(0));
      const fn = list.__lookup__(new Int(1));
      if (schema.valid_q(value).to_js()) {
        return fn;
      } else {
        return Nil.new();
      }
    });
    if (fn.nil_q().to_js()) throw new MatchError();
    return fn(value);
  }

  static or(...schema) {
    return new OrSchema(...schema);
  }

  static and(a, b) {
    [a, b] = [Schema.for(a), Schema.for(b)];
    if (a instanceof RecordSchema && b instanceof RecordSchema) {
      return a.combine(b);
    }
    return new AndSchema(a, b);
  }

  static any(name) {
    return new AnySchema(name.to_js());
  }

  static literal(value) {
    return new LiteralSchema(value);
  }

  constructor(schema) {
    this.schema_ = schema;
  }

  valid_q(other) {
    throw null;
  }

  valid_b(other) {
    if (!this.valid_q(other).to_js()) {
      throw new MatchError();
    }
    return other;
  }
}

class OrSchema extends Schema {
  constructor(...schema) {
    super(schema.map(Schema.for));
  }
  valid_q(other) {
    return Bool.new(this.schema_.some((s) => s.valid_q(other).to_js()));
  }
}

class AndSchema extends Schema {
  constructor(...schema) {
    super(schema.map(Schema.for));
  }
  valid_q(other) {
    return Bool.new(this.schema_.every((s) => s.valid_q(other).to_js()));
  }
}

class RecordSchema extends Schema {
  constructor(schema) {
    schema = schema.map((k, v) => {
      return List.new([k, Schema.for(v)]);
    });
    super(schema);
  }

  combine(other) {
    if (!(other instanceof RecordSchema)) throw new NotReached();
    let newSchema = this.schema_.combine(other.schema_);
    return new RecordSchema(newSchema);
  }

  valid_q(other) {
    if (other instanceof Nil) {
      return Bool.new(false);
    }
    return this.schema_.every((k, v) =>
      other.has_q(k).__and__(v.valid_q(other.__lookup__(k)))
    );
  }
}

class ListSchema extends Schema {
  constructor(value) {
    if (value instanceof Array) {
      value = List.new(value);
    }
    value = value.map(Schema.for);
    super(value);
  }
  valid_q(other) {
    if (!(other instanceof List)) return new Bool(false);
    const otherSize = other.size().to_js();
    return new Bool(
      otherSize === this.schema_.size().to_js() &&
        this.schema_.every((s, i) => s.valid_q(other.__lookup__(i))).to_js()
    );
  }
}

class FnSchema extends Schema {
  valid_q(other) {
    return this.schema_(other);
  }
}

class AnySchema extends Schema {
  valid_q(other) {
    return Bool.new(true);
  }
}

class LiteralSchema extends Schema {
  valid_q(other) {
    return this.schema_.__eq__(other);
  }
}

class NotReached extends Error {
  constructor(...artifacts) {
    console.log(...artifacts);
    super();
  }
}

class StringScanner {
  index = 0;
  matched = null;
  groups = [];
  constructor(str) {
    this.str = str;
  }

  scan(regex) {
    const result = this.rest_of_str().match(regex);
    if (result === null || result.index !== 0) return false;
    const [matched, ...groups] = Array.from(result);
    this.index += matched.length;
    this.matched = matched;
    this.groups = groups;
    return true;
  }

  rest_of_str() {
    return this.str.slice(this.index);
  }

  is_end_of_str() {
    return this.index >= this.str.length;
  }
}

class Token {
  constructor(value) {
    this.value = value;
  }
  is(TokenType) {
    return this instanceof TokenType;
  }
}
class ValueToken extends Token {}
class IdentifierToken extends Token {}
class OpenBrace extends Token {}
class CloseBrace extends Token {}
class Ampersand extends Token {}
class PseudoClass extends Token {}
class PseudoElement extends Token {}
class Dot extends Token {}
class Comma extends Token {}

const tokenizeCSS = (str) => {
  const tokens = [];
  const scanner = new StringScanner(str);
  while (!scanner.is_end_of_str()) {
    if (scanner.scan(/\s+/)) {
      continue;
    } else if (scanner.scan(/&/)) {
      tokens.push(new Ampersand());
    } else if (scanner.scan(/\./)) {
      tokens.push(new Dot());
    } else if (scanner.scan(/\,/)) {
      tokens.push(new Comma());
    } else if (scanner.scan(/::([a-z]+)/)) {
      tokens.push(new PseudoElement(scanner.groups[0]));
    } else if (scanner.scan(/:([a-z]+)/)) {
      tokens.push(new PseudoClass(scanner.groups[0]));
    } else if (scanner.scan(/:(\s)*(.*);/)) {
      tokens.push(new ValueToken(scanner.groups[1]));
    } else if (scanner.scan(/([a-z][a-z1-9\-]*|\*)/)) {
      tokens.push(new IdentifierToken(scanner.matched));
    } else if (scanner.scan(/\{/)) {
      tokens.push(new OpenBrace());
    } else if (scanner.scan(/\}/)) {
      tokens.push(new CloseBrace());
    } else {
      throw new NotReached([scanner.index, scanner.rest_of_str()]);
    }
  }
  return tokens;
};

class TokenMismatch extends Error {
  constructor(expected, got) {
    super(`expected - ${expected.name}, got - ${got.constructor.name}`);
  }
}

class AstNode {
  is(NodeType) {
    return this instanceof NodeType;
  }
}
class RuleNode extends AstNode {
  constructor(name, value) {
    super();
    this.name = name;
    this.value = value;
  }
}
class ChildSelectorNode extends AstNode {
  constructor(tag_name, rules) {
    super();
    this.tag_name = tag_name;
    this.rules = rules;
  }
}

class PseudoSelectorNode extends AstNode {
  constructor(pseudo_class, rules) {
    super();
    this.pseudo_class = pseudo_class;
    this.rules = rules;
  }
}

class PseudoElementNode extends AstNode {
  constructor(pseudo_element, rules) {
    super();
    this.pseudo_element = pseudo_element;
    this.rules = rules;
  }
}

class ClassSelectorNode extends AstNode {
  constructor(class_name, rules) {
    super();
    this.class_name = class_name;
    this.rules = rules;
  }
}

class MultipleIdentifierNode extends AstNode {
  constructor(first_tag_name, second_tag_name, rules) {
    super();
    this.first_tag_name = first_tag_name;
    this.second_tag_name = second_tag_name;
    this.rules = rules;
  }
}

class CSSParser {
  constructor(tokens, index = 0, end_token = null) {
    this.tokens = tokens;
    this.index = index;
    this.end_token = end_token;
  }

  get current() {
    return this.tokens[this.index];
  }

  get peek() {
    return this.tokens[this.index + 1];
  }

  get peek_two() {
    return this.tokens[this.index + 2];
  }

  clone(end_token = null) {
    return new CSSParser(this.tokens, this.index, end_token || this.end_token);
  }

  consume_clone(parser) {
    this.index = parser.index;
  }

  consume(TokenClass) {
    if (!(this.current instanceof TokenClass))
      throw new TokenMismatch(TokenClass, this.current);
    const token = this.current;
    this.index += 1;
    return token;
  }

  can_parse() {
    if (this.index >= this.tokens.length) return false;
    if (!this.end_token) return true;
    return !this.current.is(this.end_token);
  }

  parse() {
    const ast = [];
    while (this.can_parse()) {
      if (this.current.is(Dot) && this.peek?.is(IdentifierToken)) {
        ast.push(this.parse_class_selector());
      } else if (
        this.current.is(IdentifierToken) &&
        this.peek?.is(Comma) &&
        this.peek_two?.is(IdentifierToken)
      ) {
        ast.push(this.parse_multiple_identifier());
      } else if (this.current.is(Ampersand) && this.peek?.is(PseudoClass)) {
        ast.push(this.parse_child_pseudo_class_selector());
      } else if (this.current.is(Ampersand) && this.peek?.is(PseudoElement)) {
        ast.push(this.parse_child_pseudo_element_selector());
      } else if (this.current.is(IdentifierToken) && this.peek?.is(OpenBrace)) {
        ast.push(this.parse_child_selector());
      } else if (this.current.is(IdentifierToken)) {
        ast.push(this.parse_rule());
      } else {
        throw new NotReached(this.current);
      }
    }
    return ast;
  }

  parse_class_selector() {
    this.consume(Dot);
    const { value: class_name } = this.consume(IdentifierToken);
    this.consume(OpenBrace);
    const cloned_parser = this.clone(CloseBrace);
    const rules = cloned_parser.parse();
    this.consume_clone(cloned_parser);
    this.consume(CloseBrace);
    return new ClassSelectorNode(class_name, rules);
  }

  parse_child_pseudo_class_selector() {
    this.consume(Ampersand);
    const { value: selector } = this.consume(PseudoClass);
    this.consume(OpenBrace);
    const cloned_parser = this.clone(CloseBrace);
    const rules = cloned_parser.parse();
    this.consume_clone(cloned_parser);
    this.consume(CloseBrace);
    return new PseudoSelectorNode(selector, rules);
  }

  parse_multiple_identifier() {
    const { value: first_tag_name } = this.consume(IdentifierToken);
    this.consume(Comma);
    const { value: second_tag_name } = this.consume(IdentifierToken);
    this.consume(OpenBrace);
    const cloned_parser = this.clone(CloseBrace);
    const rules = cloned_parser.parse();
    this.consume_clone(cloned_parser);
    this.consume(CloseBrace);
    return new MultipleIdentifierNode(first_tag_name, second_tag_name, rules);
  }

  parse_child_pseudo_element_selector() {
    this.consume(Ampersand);
    const { value: pseudo_element } = this.consume(PseudoElement);
    this.consume(OpenBrace);
    const cloned_parser = this.clone(CloseBrace);
    const rules = cloned_parser.parse();
    this.consume_clone(cloned_parser);
    this.consume(CloseBrace);
    return new PseudoElementNode(pseudo_element, rules);
  }

  parse_child_selector() {
    const { value: tag_name } = this.consume(IdentifierToken);
    this.consume(OpenBrace);
    const cloned_parser = this.clone(CloseBrace);
    const rules = cloned_parser.parse();
    this.consume_clone(cloned_parser);
    this.consume(CloseBrace);
    return new ChildSelectorNode(tag_name, rules);
  }

  parse_rule() {
    const { value: name } = this.consume(IdentifierToken);
    const { value } = this.consume(ValueToken);
    return new RuleNode(name, value);
  }
}

class CSSCompiler {
  constructor(ast, parent_selector, top_level = true) {
    this.ast = ast;
    this.parent_selector = parent_selector;
    this.top_level = top_level;
  }

  base_rules_end() {
    if (this.top_level) {
      return "}\n";
    } else {
      return "";
    }
  }

  eval() {
    let rules_str = `${this.parent_selector} {\n`;
    const [rules, sub_rules] = this.eval_rules_and_sub_rules();
    return [rules_str + rules, ...sub_rules];
  }

  eval_rules_and_sub_rules() {
    let rules = "";
    const rule_nodes = this.ast.filter((node) => node instanceof RuleNode);
    for (let node of rule_nodes) {
      rules += `  ${this.eval_rule(node)}\n`;
    }
    rules += this.base_rules_end();

    let sub_rules = [];
    const sub_rule_nodes = this.ast.filter(
      (node) => !rule_nodes.includes(node)
    );
    for (let node of sub_rule_nodes) {
      switch (node.constructor) {
        case ClassSelectorNode:
          sub_rules = sub_rules.concat(this.eval_class_selector(node));
          break;
        case PseudoSelectorNode:
          sub_rules = sub_rules.concat(this.eval_pseudo_class_selector(node));
          break;
        case PseudoElementNode:
          sub_rules = sub_rules.concat(this.eval_pseudo_element_selector(node));
          break;
        case ChildSelectorNode:
          sub_rules = sub_rules.concat(this.eval_child_selector(node));
          break;
        default:
          throw new NotReached();
      }
    }
    return [rules, sub_rules];
  }

  eval_rule({ name, value }) {
    return `${name}: ${value};`;
  }

  eval_class_selector({ class_name, rules: ast }) {
    if (!class_name) throw new NotReached();
    const selector = `${this.parent_selector} .${class_name}`;
    let output = `${selector} {\n`;
    const [rules, sub_rules] = new CSSCompiler(
      ast,
      selector,
      false
    ).eval_rules_and_sub_rules();
    output += rules;
    output += "}\n";

    return [output, ...sub_rules];
  }

  eval_pseudo_class_selector({ pseudo_class, rules: ast }) {
    if (!pseudo_class) throw new NotReached();
    const selector = `${this.parent_selector}:${pseudo_class}`;
    let output = `${selector} {\n`;
    const [rules, sub_rules] = new CSSCompiler(
      ast,
      selector,
      false
    ).eval_rules_and_sub_rules();
    output += rules;
    output += "}\n";

    return [output, ...sub_rules];
  }

  eval_pseudo_element_selector({ pseudo_element, rules: ast }) {
    if (!pseudo_element) throw new NotReached();
    const selector = `${this.parent_selector}::${pseudo_element}`;
    let output = `${selector} {\n`;
    const [rules, sub_rules] = new CSSCompiler(
      ast,
      selector,
      false
    ).eval_rules_and_sub_rules();
    output += rules;
    output += "}\n";

    return [output, ...sub_rules];
  }

  eval_child_selector({ tag_name, rules: ast }) {
    const selector = `${this.parent_selector} ${tag_name}`;
    let output = `${selector} {\n`;
    const [rules, sub_rules] = new CSSCompiler(
      ast,
      selector,
      false
    ).eval_rules_and_sub_rules();
    output += rules;
    output += "}\n";

    return [output, ...sub_rules];
  }
}

const compile_css = (style, tag_name) => {
  const tokens = tokenizeCSS(style);
  const ast = new CSSParser(tokens).parse();
  return new CSSCompiler(ast, tag_name).eval();
};

const parse_css = (style) => {
  const tokens = tokenizeCSS(style);
  return new CSSParser(tokens).parse();
};
if (!globalThis.document) {
  const dom = new JSDOM();
  globalThis.document = dom.window.document;
  globalThis.Text = dom.window.Text;
}
class TypeMismatchError extends Error {}

// for classes to behave properly
Object.prototype.to_ps = function () {
  return Str.new(this.name);
};
Object.prototype.nil_q = function () {
  assert(this.constructor !== Nil);
  return Bool.new(false);
};
const assert = (bool) => {
  if (!bool) throw new NotReached();
};

Function.prototype.to_b = () => Bool.new(true);
Function.prototype.nil_q = () => Bool.new(false);

const assertType = (val, type) => {
  if (typeof val !== type && val.constructor !== type)
    throw new TypeMismatchError();
};

class Value {
  constructor(value) {
    this.__value = value;
  }
  static ["new"](...args) {
    return new this(...args);
  }
  to_js() {
    return this.__value;
  }
  to_s() {
    return Str.new(this.to_js().toString());
  }
  bang() {
    if (this.to_b().to_js()) {
      return Bool.new(false);
    } else {
      return Bool.new(true);
    }
  }
  nil_q() {
    return Bool.new(false);
  }
  is_a_q(constructor) {
    return Bool.new(this.constructor === constructor);
  }
  __eq__(other) {
    try {
      this.__check_type(other);
      return Bool.new(this.to_js() === other.to_js());
    } catch (e) {
      return Bool.new(false);
    }
  }
  __not_eq__(other) {
    try {
      this.__check_type(other);
      return Bool.new(this.to_js() !== other.to_js());
    } catch (e) {
      return Bool.new(false);
    }
  }
  __or__(other) {
    if (this.to_b().to_js()) {
      return this;
    } else {
      return other;
    }
  }
  __and__(other) {
    if (!this.to_b().to_js()) {
      return this;
    }
    if (typeof other === "function") {
      other = other();
    }
    return other;
  }

  to_b() {
    return Bool.new(!(this instanceof Nil));
  }
  __check_type(other, type = undefined) {
    if (!(other instanceof (type || this.constructor)))
      throw new TypeMismatchError();
  }
}

class Bool extends Value {
  to_ps() {
    return Str.new(this.to_js().toString().yellow);
  }
  constructor(value) {
    assertType(value, Boolean);
    super(value);
  }
  to_b() {
    return this;
  }
  __eq__(other) {
    return Bool.new(this.to_js() === other.to_js());
  }
}

class Int extends Value {
  to_ps() {
    return Str.new(this.to_js().toString().yellow);
  }
  __gt__(other) {
    this.__check_type(other);
    return Bool.new(this.to_js() > other.to_js());
  }
  __lt__(other) {
    this.__check_type(other);
    return Bool.new(this.to_js() < other.to_js());
  }
  __gt_eq__(other) {
    this.__check_type(other);
    return Bool.new(this.to_js() >= other.to_js());
  }
  __lt_eq__(other) {
    this.__check_type(other);
    return Bool.new(this.to_js() <= other.to_js());
  }
  __mult__(other) {
    this.__check_type(other);
    return Int.new(this.to_js() * other.to_js());
  }
  __div__(other) {
    this.__check_type(other);
    return Int.new(this.to_js() / other.to_js());
  }
  __plus__(other) {
    this.__check_type(other);
    return Int.new(this.to_js() + other.to_js());
  }
  __minus__(other) {
    this.__check_type(other);
    return Int.new(this.to_js() - other.to_js());
  }
}

class Float extends Value {
  to_ps() {
    return Str.new(this.to_js().toString().yellow);
  }

  to_i() {
    return Int.new(Math.floor(this.to_js()));
  }
  __gt__(other) {
    this.__check_type(other);
    return Float.new(this.to_js() > other.to_js());
  }
  __lt__(other) {
    this.__check_type(other);
    return Float.new(this.to_js() < other.to_js());
  }
  __gt_eq__(other) {
    this.__check_type(other);
    return Bool.new(this.to_js() >= other.to_js());
  }
  __lt_eq__(other) {
    this.__check_type(other);
    return Bool.new(this.to_js() <= other.to_js());
  }
  __mult__(other) {
    this.__check_type(other);
    return Float.new(this.to_js() * other.to_js());
  }
  __div__(other) {
    this.__check_type(other);
    return Float.new(this.to_js() / other.to_js());
  }
  __plus__(other) {
    this.__check_type(other);
    return Float.new(this.to_js() + other.to_js());
  }
  __minus__(other) {
    this.__check_type(other);
    return Float.new(this.to_js() - other.to_js());
  }
}

class Str extends Value {
  to_ps() {
    return Str.new(`"${this.to_js()}"`.green);
  }
  to_s() {
    return this;
  }
  to_i() {
    const val = parseInt(this.to_js());
    if (!isNaN(val)) {
      return Int.new(val);
    } else {
      return Nil.new();
    }
  }
  to_f() {
    const val = Number(this.to_js());
    if (!isNaN(val)) {
      return Float.new(val);
    } else {
      return Nil.new();
    }
  }
  trim() {
    return Str.new(this.to_js().trim());
  }
  __gt__(other) {
    this.__check_type(other);
    return Str.new(this.to_js() > other.to_js());
  }
  __lt__(other) {
    this.__check_type(other);
    return Str.new(this.to_js() < other.to_js());
  }
  __mult__(other) {
    this.__check_type(other, Int);
    let str = this.to_js();
    for (let i = 0; i < other.to_js() - 1; i++) {
      str += this.to_js();
    }
    return Str.new(str);
  }
  __plus__(other) {
    this.__check_type(other);
    return Str.new(this.to_js() + other.to_js());
  }
}

class Record extends Value {
  constructor(value, splats) {
    // TODO: remove assertTypes
    assertType(value, Array);
    assertType(splats, List);
    const size = value.length + splats.size().to_js();
    const index_to_splat = {};
    splats.each((val) => {
      const splat = val.__lookup__(Sym.new("splat"));
      const index = val.__lookup__(Sym.new("index"));
      index_to_splat[index.to_js()] = splat;
    });
    let record = [];
    let value_index = 0;
    const remove_existing = (key) => {
      for (let i = 0; i < record.length; i++) {
        if (record[i][0].__eq__(key).to_js()) {
          record.splice(i, 1);
        }
      }
    };
    for (let i = 0; i < size; i++) {
      if (index_to_splat[i]) {
        const splat = index_to_splat[i].to_js();
        for (const [key] of splat) {
          remove_existing(key);
        }
        record = record.concat(splat);
      } else {
        remove_existing(value[value_index][0]);
        record.push(value[value_index]);
        value_index++;
      }
    }
    super(record);
  }
  __lookup__(key) {
    const value = this.to_js().find(([k, v]) => {
      if (k.__eq__(key).to_js()) {
        return v;
      }
    });
    return (value && value[1]) || Nil.new();
  }
  __unsafe_insert__(key, value) {
    this.__value.push([key, value]);
  }
  size() {
    return Int.new(this.to_js().length);
  }
  __eq__(other) {
    if (this.size().__not_eq__(other.size()).to_js()) return Bool.new(false);
    return this.every((k, v) => other.__lookup__(k).__eq__(v));
  }
  has_q(key) {
    return Bool.new(
      !!this.to_js().find(([k, v]) => {
        if (k.__eq__(key).to_js()) {
          return v;
        }
      })
    );
  }
  to_l() {
    return List.new(this.to_js().map((l) => List.new(l)));
  }
  each(fn) {
    this.to_js().forEach(([key, value], i) => {
      fn(key, value, Int.new(i));
    });
  }
  remove(key) {
    let new_record = this.to_js().slice();
    new_record = new_record.filter(([k]) => !k.__eq__(key).to_js());
    return Record.new(new_record, List.new([]));
  }
  combine(record) {
    let new_record = this;
    record.each((k, v) => {
      new_record = new_record.remove(k);
      new_record = new_record.put(k, v);
    });
    return new_record;
  }
  __plus__(other) {
    return this.combine(other);
  }
  __minus__(other) {
    if (!(other instanceof List)) other = List.new([other]);
    let new_record = this;
    other.each((key) => {
      new_record = new_record.remove(key);
    });
    return new_record;
  }
  put(key, value) {
    let newRecord = this.to_js().slice();
    newRecord = newRecord.filter(([k]) => !k.__eq__(key).to_js());
    newRecord.push([key, value]);
    return Record.new(newRecord, List.new([]));
  }
  every(fn) {
    return Bool.new(
      this.to_js().every(([k, v]) => {
        return fn(k, v).to_b().to_js();
      })
    );
  }
  map(fn) {
    return Record.new(
      this.to_js().map(([k, v]) => {
        const k_v = fn(k, v);
        return [k_v.__lookup__(Int.new(0)), k_v.__lookup__(Int.new(1))];
      }),
      List.new([])
    );
  }
  to_ps() {
    if (this.size().to_js() == 0) return Str.new("{}");
    let s = "{";
    this.each((key, value, i) => {
      i = i.to_js();
      let key_s;
      if (key instanceof Sym) {
        key_s = (key.to_js().toString().slice(7, -1) + ":").blue;
      } else {
        key_s = `[${key.to_ps().to_js()}]:`;
      }
      s += ` ${key_s} ${value.to_ps().to_js()}`;
      if (i < this.size().to_js() - 1) s += ",";
    });
    return Str.new(s + " }");
  }
}

class List extends Value {
  __lookup__(index) {
    return this.to_js()[index.to_js()];
  }
  get size() {
    return Int.new(this.to_js().length);
  }
  to_l() {
    return this;
  }
  to_r() {
    const record = [];
    for (let item of this.to_js()) {
      const [k, v] = [item.__lookup__(Int.new(0)), item.__lookup__(Int.new(1))];
      record.push([k, v]);
    }
    return Record.new(record, List.new([]));
  }

  to_ps() {
    // I'm aware, this is gross lol. It'll be much better once we write it in peacock
    let s = "[";
    s += this.to_js()
      .map((val) => val.to_ps().to_js())
      .join(", ");
    s += "]";
    return Str.new(s);
  }

  __eq__(other) {
    this.__check_type(other);
    if (this === other) return Bool.new(true);
    return this.every((item, i) => item.__eq__(other.__lookup__(i)));
  }

  __plus__(other) {
    this.__check_type(other);
    return List.new([...this.to_js(), ...other.to_js()]);
  }

  has_q(other) {
    return Bool.new(this.to_js().some((val) => val.__eq__(other).to_js()));
  }

  every(fn) {
    for (let i = 0; i < this.to_js().length; i++) {
      const result = fn(this.to_js()[i], Int.new(i));
      if (!result.to_js()) {
        return Bool.new(false);
      }
    }
    return Bool.new(true);
  }

  any_q(fn) {
    for (let i = 0; i < this.to_js().length; i++) {
      const result = fn(this.to_js()[i], Int.new(i));
      if (result.to_js()) {
        return Bool.new(true);
      }
    }
    return Bool.new(false);
  }

  flat() {
    let new_list = [];
    for (let list of this.to_js()) {
      assertType(list, List);
      new_list = new_list.concat(list.to_js());
    }
    return List.new(new_list);
  }

  size() {
    return Int.new(this.to_js().length);
  }

  find(fn) {
    for (let item of this.to_js()) {
      const result = fn(item);
      // This is definitely wrong
      if (result.to_b().to_js()) return item;
    }
    return Nil.new();
  }

  first(fn) {
    for (let item of this.to_js()) {
      const result = fn(item);
      // This is definitely wrong
      if (result.to_b().to_js()) return result;
    }
    return Nil.new();
  }

  map(fn) {
    return List.new(this.to_js().map((item, i) => fn(item, Int.new(i), this)));
  }

  push(val) {
    return List.new([...this.to_js(), val]);
  }

  last_index() {
    return Int.new(this.size().to_js() - 1);
  }

  each(fn) {
    this.to_js().forEach((val, i) => fn(val, Int.new(i)));
  }

  filter(fn) {
    return List.new(
      this.to_js().filter((v) => {
        const result = fn(v);
        // this.__check_type(result, Bool);
        return result.to_b().to_js();
      })
    );
  }

  __minus__(other) {
    this.__check_type(other);
    return this.filter((val) => other.has_q(val));
  }
}

class Sym extends Value {
  static __SYMBOLS = {};
  static _create_sym(name) {
    if (Sym.__SYMBOLS[name]) {
      return Sym.__SYMBOLS[name];
    } else {
      Sym.__SYMBOLS[name] = Symbol(name);
      return Sym.__SYMBOLS[name];
    }
  }
  constructor(sym) {
    if (typeof sym === "symbol") {
      super(sym);
    } else if (sym instanceof Str) {
      super(Sym._create_sym(sym.to_js()));
    } else if (typeof sym === "string") {
      super(Sym._create_sym(sym));
    } else {
      throw new NotReached();
    }
  }

  to_s() {
    return Str.new(`${this.to_js().toString().slice(7, -1)}`);
  }

  to_ps() {
    return Str.new(`:${this.to_js().toString().slice(7, -1)}`.blue);
  }
}

class Nil extends Value {
  nil_q() {
    return Bool.new(true);
  }

  to_s() {
    return Str.new("");
  }

  to_ps() {
    return Str.new("nil".blue);
  }
}

class DomNode {
  constructor(name, attributes, children) {
    assertType(name, Str);
    assertType(attributes, Record);
    assertType(children, List);
    this.name = name;
    this.attributes = attributes;
    this.children = children;
  }
  static ["new"](name, attributes, children) {
    return new DomNode(name, attributes, children);
  }
  _can_render(elem) {
    return (
      elem instanceof DomTextNode ||
      elem instanceof DomNode ||
      elem instanceof Element
    );
  }
  render_list(list, elem) {
    list.each((child) => {
      if (child instanceof Nil) {
        // nothing
      } else if (this._can_render(child)) {
        elem.append(child.to_dom());
      } else if (child instanceof Str) {
        elem.append(DomTextNode.new(child.to_s()).to_dom());
      } else if (child instanceof List) {
        this.render_list(child, elem);
      } else {
        debugger;
        throw new NotReached();
      }
    });
  }
  to_dom() {
    const bool_attrs = ["open", "disabled", "checked"];
    const elem = document.createElement(this.name.to_js());
    this.attributes.each((name, value) => {
      name = name.to_s().to_js();
      if (typeof value === "function") {
        elem[name] = value;
      } else if (bool_attrs.includes(name)) {
        if (value.to_b().to_js()) {
          elem.setAttribute(name, value.to_js());
        }
      } else {
        if (name == "class_name") {
          name = "class";
        }
        elem.setAttribute(name, value.to_js());
      }
    });
    this.children.each((expr) => {
      if (typeof expr === "function") expr = expr();
      if (expr instanceof List) {
        this.render_list(expr, elem);
      } else if (this._can_render(expr)) {
        const dom = expr.to_dom();
        if (!(dom instanceof NilNode)) elem.append(dom);
      } else if (expr instanceof Nil) {
        // do nothing
      } else {
        const node = DomTextNode.new(expr.to_s()).to_dom();
        if (node instanceof Text && node.nodeValue.match(/[a-zA-Z]+/)) {
          node.nodeValue += " ";
        }
        elem.append(node);
      }
    });
    return elem;
  }

  inner_text() {
    return Str.new(this.to_dom().textContent);
  }
}

class DomTextNode extends Value {
  to_dom() {
    // TODO: find way to not have __value double nested like this
    return document.createTextNode(this.__value.to_js());
  }
}

class NilNode extends Value {
  to_dom() {
    return Nil.new();
  }
}

class Context extends Value {
  constructor(val = Nil.new()) {
    super(val);
  }
  listeners = [];
  _register_listener(fn) {
    this.listeners.push(fn);
  }
  value() {
    return this.__value;
  }
  set_value(v) {
    this.__value = v;
    this.listeners.forEach((fn) => fn(v));
  }
}

function js_lookup(obj, ...path) {
  path = path.map((x) => x.to_js());
  let result = obj;
  for (const k of path) {
    result = result[k];
  }
  if (typeof result == "string") {
    return Str.new(result);
  }
  throw new NotReached();
}

class Element {
  init_state() {
    return Nil.new();
  }
  constructor(props) {
    this._props = props;
    this.use_context();
    this.set_state = this.set_state.bind(this);
    this.set_context = this.set_context.bind(this);
  }

  // test helpers

  inner_text() {
    return Str.new(this.to_dom().textContent);
  }

  context() {
    return Nil.new();
  }
  context_value() {
    return (this.context().value && this.context().value()) || Nil.new();
  }
  set_context(value) {
    if (!(this.context() instanceof Context)) throw new NotReached();
    this.context().set_value(value);
  }
  use_context() {
    if (this.context() instanceof Context) {
      this.context()._register_listener(() => this.render_to_dom());
    }
  }
  set_timeout(fn, delay) {
    setTimeout(fn, delay.to_js());
  }
  static style_sheet;
  static ["new"](props) {
    return new this(props);
  }
  _class_name;
  __generate_element_id() {
    if (this._class_name) throw new NotReached();
    const id = Array.from({ length: 10 })
      .map((i) => parseInt(Math.random() * 10))
      .join("");
    this._class_name = "c" + id;
    return this._class_name;
  }
  create_style_sheet() {
    if (Element.style_sheet) return Element.style_sheet;
    Element.style_sheet = document.createElement("style");
    document.body.append(Element.style_sheet);
    return Element.style_sheet;
  }
  style() {
    return Str.new("");
  }
  _state;
  state() {
    if (!this._state) {
      return (this._state = this.init_state());
    } else {
      return this._state;
    }
  }
  props() {
    return this._props || Nil.new();
  }
  set_state(value) {
    this._state = value;
    this.render_to_dom();
  }

  prev_props = Nil.new();
  prev_state = Nil.new();
  prev_context = Nil.new();
  render_to_dom() {
    if (
      this.prev_state.__eq__(this.state()).to_js() &&
      this.prev_props.__eq__(this.props()).to_js() &&
      this.prev_context.__eq__(this.context_value()).to_js()
    ) {
      return;
    }
    const node = this.to_dom();
    const [class_name] = node.classList;
    assert(this.class_name() === class_name);
    const elements = document.getElementsByClassName(class_name);
    assert(elements.length === 1);
    elements[0].replaceWith(node);
  }

  view() {
    return Nil.new();
  }
  class_name() {
    return this._class_name || this.__generate_element_id();
  }
  replace_styles() {
    // TODO: this has serious issues, needs to be made recursive
    // but it partially works..
    const { sheet } = this.create_style_sheet();
    const ast = parse_css(this._compute_style());

    const root_rules = ast.filter((node) => node.is(RuleNode));
    const this_elem_selector = `.${this.class_name()}`;

    for (const rule of sheet.cssRules) {
      if (!rule.selectorText.includes(this_elem_selector)) continue;
      const rest_of_selector = rule.selectorText
        .slice(
          rule.selectorText.indexOf(this_elem_selector) +
            this_elem_selector.length
        )
        .trim();
      const tokens = tokenizeCSS(rest_of_selector);
      assert(tokens.length <= 2);
      const [token, peek] = tokens;
      console.log(token, peek);
      if (tokens.length === 0) {
        root_rules.forEach(({ name, value }) => {
          rule.style[name] = value;
        });
      } else if (token.is(PseudoElement)) {
        const { rules } = ast.find(
          (node) =>
            node.is(PseudoElementNode) && node.pseudo_element === token.value
        );
        assert(rules.every((node) => node.is(RuleNode)));
        rules.forEach(({ name, value }) => {
          rule.style[name] = value;
        });
      } else if (token.is(PseudoClass)) {
        const { rules } = ast.find(
          (node) =>
            node.is(PseudoSelectorNode) && node.pseudo_class === token.value
        );
        assert(rules.every((node) => node.is(RuleNode)));
        rules.forEach(({ name, value }) => {
          rule.style[name] = value;
        });
      } else if (token.is(Dot) && peek?.is(IdentifierToken)) {
        const { rules } = ast.find(
          (node) => node.is(ClassSelectorNode) && node.value === peek.value
        );
        assert(rules.every((node) => node.is(RuleNode)));
        rules.forEach(({ name, value }) => {
          rule.style[name] = value;
        });
      } else if (token.is(IdentifierToken)) {
        const { rules } = ast.find(
          (node) => node.is(ChildSelectorNode) && node.tag_name == token.value
        );
        assert(rules.every((node) => node.is(RuleNode)));
        rules.forEach(({ name, value }) => {
          rule.style[name] = value;
        });
      } else {
        throw new NotReached();
      }
    }
  }
  create_styles() {
    const { sheet } = this.create_style_sheet();
    const styles = compile_css(this._compute_style(), `.${this.class_name()}`);
    for (let style of styles) {
      sheet.insertRule(style);
    }
  }
  _styles_created = false;
  create_or_replace_styles() {
    if (this._styles_created) {
      this.replace_styles();
    } else {
      this._styles_created = true;
      this.create_styles();
    }
  }
  _compute_style() {
    return this.style(this.props(), this.state(), this.context_value()).to_js();
  }
  has_class_name(elem) {
    return elem.attributes
      .__lookup__(Sym.new("class_name"))
      .nil_q()
      .bang()
      .to_js();
  }
  to_dom() {
    const elem = this.view(this.props(), this.state(), this.context_value());
    if (elem instanceof Element) throw new NotReached();
    if (this.has_class_name(elem)) throw new NotReached();
    this.prev_state = this.state();
    this.prev_props = this.props();
    this.prev_context = this.context_value();
    this.create_or_replace_styles();
    const new_attrs = elem.attributes.put(
      Sym.new("class"),
      Str.new(this.class_name())
    );
    return DomNode.new(elem.name, new_attrs, elem.children).to_dom();
  }
}

class Div extends Element {
  view(props) {
    return DomNode.new(
      Str.new("div"),
      props,
      List.new([props.__lookup__(Sym.new("children"))])
    );
  }
}

class Article extends Element {
  view(props) {
    return DomNode.new(
      Str.new("article"),
      props,
      List.new([props.__lookup__(Sym.new("children"))])
    );
  }
}

class Details extends Element {
  view(props) {
    return DomNode.new(
      Str.new("details"),
      props,
      List.new([props.__lookup__(Sym.new("children"))])
    );
  }
}

class A extends Element {
  view(props) {
    return DomNode.new(
      Str.new("a"),
      props,
      List.new([props.__lookup__(Sym.new("children"))])
    );
  }
}

const mount_element = (ElementClass, node) => {
  const elem = ElementClass.new();
  if (elem.title) {
    document.title = elem.title().to_js();
  }
  if (elem.favicon) {
    document
      .getElementById("favicon")
      .setAttribute("href", elem.favicon().to_js());
  }
  node.append(elem.to_dom());
};

const print = (...params) => {
  console.log(...params.map((p) => p.to_ps().to_js()));
};
const inspect = { print };

const document_body = globalThis.document && document.body;

const __try = (fn) => {
  try {
    return fn();
  } catch (e) {
    return undefined;
  }
};

// TODO: at some point use this character for printing debug strs â€Ž
class Expect {
  constructor(test_value) {
    this.test_value = test_value;
  }
  static ["new"](...params) {
    return new this(...params);
  }
  to(result) {
    return result.test(this.test_value);
  }
}
class ExpectResult {
  constructor(test_value) {
    this.test_value = test_value;
  }
  static ["new"](...params) {
    return new this(...params);
  }
  test(value) {
    return this.test_value.__eq__(value);
  }
}

const eq = (val) => {
  return ExpectResult.new(val);
};

const expect = (val) => {
  return Expect.new(val);
};

class SpecContext {
  tests = [];
  test_fn;
  constructor(parent_name) {
    this.parent_name = parent_name;
  }
  static ["new"](...params) {
    return new this(...params);
  }
  it(test_name, test_fn) {
    this.tests.push({ test_name, test_fn });
  }
  xit(test_name, test_fn) {
    this.tests.push({ ignored: true, test_name, test_fn });
  }
  run_tests() {
    for (const { test_name, test_fn, ignored } of this.tests) {
      if (ignored) {
        process.stdout.write(".".yellow);
        continue;
      }
      const test_str = this.parent_name
        .__plus__(Str.new(" "))
        .__plus__(test_name)
        .to_js();
      let result;
      try {
        result = test_fn();
        if (result.nil_q().to_js()) result = Bool.new(true);
      } catch (e) {
        console.error(e);
        result = Bool.new(false);
      }
      if (result.to_js()) {
        process.stdout.write(".".green);
      } else {
        console.log(test_str.red);
      }
    }
  }
}

class Spec {
  constructor(name, context_fn) {
    if (typeof name === "function") name = Str.new(name.name);
    this.name = name;
    this.context_fn = context_fn;
    this.run();
  }
  static ["new"](...params) {
    return new this(...params);
  }

  run() {
    let context = SpecContext.new(this.name);
    this.context_fn(context);
    context.run_tests();
  }
}
let pea_module;
pea_module = Record.new([

], List.new([]));
class CodeHighlighter extends Element {
    constructor(...args) {super(...args);this.view = this.view.bind(this);this.init && this.init(...args);}
  view(...params) {
  return Schema.case(List.new(params),
    List.new([
      List.new([Schema.for(List.new([Schema.any(Sym.new("_56109")), Schema.any(Sym.new("_56110")), Schema.any(Sym.new("_56111"))])), ((__VALUE) => {
    let _56109, _56110, _56111;
    _56109 = __VALUE.__lookup__(Int.new(0));
    _56110 = __VALUE.__lookup__(Int.new(1));
    _56111 = __VALUE.__lookup__(Int.new(2));
    return DomNode.new(Str.new(`script`), Record.new([
      [Sym.new("src"), Str.new(`https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js`)]
    ], List.new([])), List.new([]));
  })])
    ])
  );
}

};
class Main extends Element {
    constructor(...args) {super(...args);this.title = this.title.bind(this);
this.style = this.style.bind(this);
this.view = this.view.bind(this);this.init && this.init(...args);}
  title(...params) {
  return Schema.case(List.new(params),
    List.new([
      List.new([Schema.for(List.new([])), ((__VALUE) => {
    return Str.new(`Marcelle Rusu - The Cost of Abstraction`);
  })])
    ])
  );
}
style(...params) {
  return Schema.case(List.new(params),
    List.new([
      List.new([Schema.for(List.new([Schema.any(Sym.new("_56112")), Schema.any(Sym.new("_56113")), Schema.any(Sym.new("_56114"))])), ((__VALUE) => {
    let _56112, _56113, _56114;
    _56112 = __VALUE.__lookup__(Int.new(0));
    _56113 = __VALUE.__lookup__(Int.new(1));
    _56114 = __VALUE.__lookup__(Int.new(2));
    return Str.new(`
    display: flex;
    flex-direction: column;
    padding: 2em;
    background: #f8f8ff;
    font-family: 'Zen Kaku Gothic Antique', sans-serif;
    a {
      color: black;
      font-style: italic;
      &:focus {
        color: purple;
      }
      &:hover {
        color: grey;
      }
    }
    hr {
      width: 100%;
      display: block;
      border-top: 0.5px solid black;
    }
    h1 {
      text-align: center;
    }
    h2 {
      position: sticky;
      top: 1.25em;
      background: #f8f8ff;
      width: 8em;
      &::before {
        content: '# ';
      }
    }
    h3 {
      position: sticky;
      top: 3.75em;
      background: #f8f8ff;
      width: 14em;
      &::before {
        content: '## ';
      }
    }
    p {
      font-weight: bolder;
      margin: 0.4em;
    }
    pre {
      width: 60%;
      margin-left: 20%;
      background: white;
    }
    .middle {
      text-align: center;
    }
    .bold {
      font-weight: 1000;
      font-size: 1.5em;
    }
    header {
      background: #f8f8ffee;
      width: calc(100vw - 4em);
      position: sticky;
      margin-left: -2em;
      padding-left: 2em;
      padding-right: 2em;
      left: 0;
      top: 0;
      .name-and-date {
        padding-top: 1em;
        display: flex;
        justify-content: space-between;
      }
    }
    .no-margin {
      margin: 0;
    }
    .indent {
      text-indent: 2em;
    }
  `);
  })])
    ])
  );
}
view(...params) {
  return Schema.case(List.new(params),
    List.new([
      List.new([Schema.for(List.new([Schema.any(Sym.new("_56115")), Schema.any(Sym.new("_56116")), Schema.any(Sym.new("_56117"))])), ((__VALUE) => {
    let _56115, _56116, _56117;
    _56115 = __VALUE.__lookup__(Int.new(0));
    _56116 = __VALUE.__lookup__(Int.new(1));
    _56117 = __VALUE.__lookup__(Int.new(2));
    return DomNode.new(Str.new(`div`), Record.new([

    ], List.new([])), List.new([CodeHighlighter.new(Record.new([

    ], List.new([]))), DomNode.new(Str.new(`header`), Record.new([
      [Sym.new("class_name"), Str.new(`header`)]
    ], List.new([])), List.new([DomNode.new(Str.new(`h1`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`The Cost of Abstraction`))])), DomNode.new(Str.new(`div`), Record.new([
      [Sym.new("class_name"), Str.new(`name-and-date`)]
    ], List.new([])), List.new([DomNode.new(Str.new(`div`), Record.new([
      [Sym.new("class_name"), Str.new(`date`)]
    ], List.new([])), List.new([Str.new(`February 28, 2022`)])), DomNode.new(Str.new(`div`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Marcelle Rusu`))]))])), DomNode.new(Str.new(`hr`), Record.new([

    ], List.new([])), List.new([]))])), DomNode.new(Str.new(`p`), Record.new([
      [Sym.new("class_name"), Str.new(`indent`)]
    ], List.new([])), List.new([Str.new(`
        Programming is hard to get right. Sometimes we can effectively minimize complexity by finding shared patterns. Other times we just hide the complexity but it doesn't go away.
        `)])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([Str.new(`
        Whether its making a web-app from the ground up, dealing with messy APIs, handling a tricky css edge-case, or designing your own language. You will have to think about the problem, you will have to research, and you will have come up with a set of steps to address the concern at hand. These problems don't go away by minimizing character count of your program, or encoding them in a compile-time system like types.
        `)])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([Str.new(`
        When you face an issue in your code - something is duplicated, something is 'gross' (TODO), etc. I argue the prime goal is to create maintainable code. To me, this means ease to understand AND update. 
        `)])), DomNode.new(Str.new(`h2`), Record.new([
      [Sym.new("id"), Str.new(`maintainable`)]
    ], List.new([])), List.new([DomTextNode.new(Str.new(`Maintainable`))])), DomNode.new(Str.new(`p`), Record.new([
      [Sym.new("class_name"), Str.new(`indent`)]
    ], List.new([])), List.new([Str.new(`
        We all know that maintainability matters for software design. Whether its because developers on a project can change, or because design choices early on can hurt later on, being able to still make quick & effective changes to your software is what enables long-term success.
        `)])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([Str.new(`
        That being said, I don't think as an industry we `), DomNode.new(Str.new(`em`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`really`))])), Str.new(` know what it means for software to be maintainable. For example, maintainable often gets conflated with 'using the correct design patterns'. There are 2 problems with this as I see it
        `), DomNode.new(Str.new(`ul`), Record.new([

    ], List.new([])), List.new([DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Of the design patterns that apply, which one should I use?`)), DomNode.new(Str.new(`ul`), Record.new([

    ], List.new([])), List.new([DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Object Oriented vs Procedural vs Functional`))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Composition vs Inheritance`))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`TODO`))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Etc.`))]))]))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`At what point does the pattern start to work against your current example.`))]))])), DomTextNode.new(Str.new(`The first point is what we mostly focus on & understandably. Design patterns & paradigms change the way we think about code/data, we should develop these ideas further. That being said, I`)), Str.new(` don't`), DomTextNode.new(Str.new(`believe its the primary cause of poor design. Rather its a lack of discipline in knowing when to stop following where the abstraction leads. This is also a form of ideology which limits your ability to see the beauty in what could be considered competeting design patterns.`))])), DomNode.new(Str.new(`h2`), Record.new([
      [Sym.new("id"), Str.new(`cognitive-load`)]
    ], List.new([])), List.new([DomTextNode.new(Str.new(`Cognitive Load`))])), DomNode.new(Str.new(`p`), Record.new([
      [Sym.new("class_name"), Str.new(`indent`)]
    ], List.new([])), List.new([DomNode.new(Str.new(`a`), Record.new([
      [Sym.new("href"), Str.new(`https://en.wikipedia.org/wiki/Cognitive_load`)],
      [Sym.new("target"), Str.new(`_blank`)]
    ], List.new([])), List.new([DomTextNode.new(Str.new(`Cognitive load theory`))])), Str.new(` `), DomTextNode.new(Str.new(`shows us that our working memory is limited & more importantly that we can easily overload our working memory. In certain cases this can turn into mild-to-extreme burnout. In practice I found this to mean that when I hit a wall I can easily conflate my failure to tackle the problem in one go with my inherent ability as a developer.`))])), DomNode.new(Str.new(`p`), Record.new([
      [Sym.new("class_name"), Str.new(`middle bold`)]
    ], List.new([])), List.new([DomTextNode.new(Str.new(`This is wrong.`))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomNode.new(Str.new(`ul`), Record.new([

    ], List.new([])), List.new([DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Breaking large tasks down into small bite-sized chunks is a difficult skill, & one that we do not talk about enough. It is not easy & it is life-changing.`))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Getting overwhelmed has nothing to do with your smartness! Say that again.`))]))]))])), DomNode.new(Str.new(`h2`), Record.new([
      [Sym.new("id"), Str.new(`example`)]
    ], List.new([])), List.new([DomTextNode.new(Str.new(`Examples`))])), DomNode.new(Str.new(`p`), Record.new([
      [Sym.new("class_name"), Str.new(`indent`)]
    ], List.new([])), List.new([Str.new(`
        We'll take a look at 3 different examples to see how different abstractions affect cognitive load & maintainability.
        `)])), DomNode.new(Str.new(`h3`), Record.new([
      [Sym.new("id"), Str.new(`declarative-programming`)]
    ], List.new([])), List.new([DomTextNode.new(Str.new(`Declarative Programming`))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([Str.new(`
        Let's take an example of transforming data between data types.
        `)])), DomNode.new(Str.new(`pre`), Record.new([
      [Sym.new("class_name"), Str.new(`prettyprint`)]
    ], List.new([])), List.new([Str.new(`const listHeaders = [['Key', 'value'], ..];`)])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`The goal is to tranform the key-value list from above into a plain object.`))])), DomNode.new(Str.new(`pre`), Record.new([
      [Sym.new("class_name"), Str.new(`prettyprint`)]
    ], List.new([])), List.new([Str.new(`
  listHeaders.reduce((headers, ([key, value]) => 
    ({...headers, [key]: value })
  ));
        `)])), DomNode.new(Str.new(`p`), Record.new([
      [Sym.new("class_name"), Str.new(`middle no-margin`)]
    ], List.new([])), List.new([DomTextNode.new(Str.new(`Verus`))])), DomNode.new(Str.new(`pre`), Record.new([
      [Sym.new("class_name"), Str.new(`prettyprint`)]
    ], List.new([])), List.new([Str.new(`
  const headers = {};
  for (let [key, value] of listHeaders) {
    headers[key] = value;
  }
        `)])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([Str.new(`
        This is a bit of a contrived example, but it is a real-life example something I wrote before & felt very clever about it.
        `)])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`I want to tackle this not in a design principles way, but with cognitive load in mind.`))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([Str.new(`Let's see what mental steps I take to parse & interpret.`), DomNode.new(Str.new(`ol`), Record.new([

    ], List.new([])), List.new([DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Reduce is a way to transform a collection into something else, lets try it out!`))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([Str.new(`
            It takes a callback, the first argument is what again? Oh right, its what we are transforming into. I guess we're making headers?
            `)])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([Str.new(`
            Right, we have to return back a partially made version of the collection we are creating. I wish I had something like Object.immutablePush.. ok whatever I'll just use spread.
            `)])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([Str.new(`
            Spreading has order in it, so always make sure to spread first or else your new value could get overridden.
            `)])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([Str.new(`All done!`)]))]))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([Str.new(`
        I'll admit some of this is a bit trivial, but I think it's worth mentioning. 
        `)])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`To me the key parts are:`)), DomNode.new(Str.new(`ol`), Record.new([

    ], List.new([])), List.new([DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`The cost of a function with multiple parameters`))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`The cost of declarative thinking`))]))]))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`In contrast, lets take that good old for loop.`)), DomNode.new(Str.new(`ol`), Record.new([

    ], List.new([])), List.new([DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Looks like`)), Str.new(` I'll`), DomTextNode.new(Str.new(`be getting the result of this in an object called headers`))])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([Str.new(`Destructure key - value from oldHeaders (order matters!)`)])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([Str.new(`Assign headers[key] to the value`)])), DomNode.new(Str.new(`li`), Record.new([

    ], List.new([])), List.new([Str.new(`All done!`)]))]))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`The biggest issue with declarative programming is exactly what sold me on it. You have to have the entire problem in your head to be able to start writing it. Likewise, you have to have the entire piece of code in your head before you can begin to understand it.`))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`I actually found this to make me a better programmer - think about the problem before you do it.`))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`Unforunately I found a common issue in practice - you`)), Str.new(` don't`), DomTextNode.new(Str.new(`have an easy point where your mind can pause half-way through a transformation & think about what you are doing. You are deep in callbacks & object/array spreads which undeniably increases cognitive load.`))])), DomNode.new(Str.new(`p`), Record.new([

    ], List.new([])), List.new([DomTextNode.new(Str.new(`So to go back to the example above, even though`)), Str.new(`there's`), DomTextNode.new(Str.new(`only`)), Str.new(` 1 `), DomTextNode.new(Str.new(`extra step, I find in practice I end up having to hold a lot more steps in my head at the same time.`))]))]));
  })])
    ])
  );
}

};
__try(() => eval('Main')) && mount_element(Main, document.getElementById('main'))</script>
    <style>
      body {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }
    </style>
  </html>
